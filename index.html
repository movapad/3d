<!DOCTYPE html>
<html>
<head>
  <title>MOVApad</title>
    <style>
        #container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        .view {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
        }
        canvas {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="view">
            <canvas id="3dView"></canvas>
        </div>
        <div class="view">
            <canvas id="technicalViews"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 3D View Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/2/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('3dView'),
            antialias: true
        });

        // Device dimensions
        const dimensions = {
            diameter: 50,
            height: 8,
            innerDiameter: 45
        };

        // Create device body
        function createDevice() {
            const geometry = new THREE.CylinderGeometry(
                dimensions.diameter/2, 
                dimensions.diameter/2, 
                dimensions.height, 
                32
            );
            const material = new THREE.MeshPhongMaterial({
                color: 0x303030,
                specular: 0x111111,
                shininess: 100
            });
            return new THREE.Mesh(geometry, material);
        }

        // Create touch surface
        function createTouchSurface() {
            const geometry = new THREE.CircleGeometry(dimensions.diameter/2 - 1, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0x404040,
                transparent: true,
                opacity: 0.9
            });
            const surface = new THREE.Mesh(geometry, material);
            surface.position.y = dimensions.height/2 + 0.01;
            surface.rotation.x = -Math.PI/2;
            return surface;
        }

        // Create coil visualization
        function createCoil() {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(dimensions.innerDiameter/4, 0, 0),
                new THREE.Vector3(0, dimensions.height/4, dimensions.innerDiameter/4),
                new THREE.Vector3(-dimensions.innerDiameter/4, 0, 0),
                new THREE.Vector3(0, -dimensions.height/4, -dimensions.innerDiameter/4),
            ]);

            const geometry = new THREE.TubeGeometry(curve, 64, 0.5, 8, true);
            const material = new THREE.MeshPhongMaterial({
                color: 0xcd7f32,
                specular: 0x666666,
                shininess: 50
            });
            return new THREE.Mesh(geometry, material);
        }

        // Initialize scene
        function init() {
            // Setup renderer
            renderer.setSize(window.innerWidth/2, window.innerHeight);
            renderer.setClearColor(0xffffff);

            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Add device components
            const device = createDevice();
            scene.add(device);

            const touchSurface = createTouchSurface();
            scene.add(touchSurface);

            const coil = createCoil();
            scene.add(coil);

            // Camera position
            camera.position.z = 100;
            camera.position.y = 50;
            camera.lookAt(0, 0, 0);

            // Animation
            function animate() {
                requestAnimationFrame(animate);
                device.rotation.y += 0.005;
                touchSurface.rotation.y += 0.005;
                coil.rotation.y += 0.005;
                renderer.render(scene, camera);
            }
            animate();
        }

        init();

        // Technical Views
        const technicalContext = document.getElementById('technicalViews').getContext('2d');

        function drawTechnicalViews() {
            const ctx = technicalContext;
            const scale = 4; // Scale factor for drawing

            // Top view
            ctx.save();
            ctx.translate(100, 100);
            ctx.beginPath();
            ctx.arc(0, 0, dimensions.diameter * scale / 2, 0, Math.PI * 2);
            ctx.strokeStyle = 'black';
            ctx.stroke();
            
            // Inner circles for coil
            ctx.beginPath();
            ctx.arc(0, 0, dimensions.innerDiameter * scale / 2, 0, Math.PI * 2);
            ctx.strokeStyle = '#cd7f32';
            ctx.stroke();
            
            // Dimensions
            ctx.beginPath();
            ctx.moveTo(-dimensions.diameter * scale / 2, 30);
            ctx.lineTo(dimensions.diameter * scale / 2, 30);
            ctx.strokeStyle = 'blue';
            ctx.stroke();
            ctx.fillText(`${dimensions.diameter}mm`, -10, 45);
            ctx.restore();

            // Front view
            ctx.save();
            ctx.translate(300, 100);
            ctx.beginPath();
            ctx.rect(-dimensions.diameter * scale / 2, -dimensions.height * scale / 2,
                    dimensions.diameter * scale, dimensions.height * scale);
            ctx.strokeStyle = 'black';
            ctx.stroke();
            
            // Dimensions
            ctx.beginPath();
            ctx.moveTo(-dimensions.diameter * scale / 2 - 10, -dimensions.height * scale / 2);
            ctx.lineTo(-dimensions.diameter * scale / 2 - 10, dimensions.height * scale / 2);
            ctx.strokeStyle = 'blue';
            ctx.stroke();
            ctx.fillText(`${dimensions.height}mm`, -dimensions.diameter * scale / 2 - 25, 0);
            ctx.restore();

            // Side view
            ctx.save();
            ctx.translate(500, 100);
            ctx.beginPath();
            ctx.rect(-dimensions.height * scale / 2, -dimensions.diameter * scale / 2,
                    dimensions.height * scale, dimensions.diameter * scale);
            ctx.strokeStyle = 'black';
            ctx.stroke();
            ctx.restore();
        }

        drawTechnicalViews();
    </script>
</body>
</html>
